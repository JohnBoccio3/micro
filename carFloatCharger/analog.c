/*
* ADC functions for attiny13.
* Author: Guido Socher, Copyright: GPL 
* http://tuxgraphics.org/electronics/
*/
#include <avr/io.h>
#include <math.h>


void adcOn(void)
{
	// Set up the ADC and enable the interrupt.
   
	// Use Vcc as Vref.
    ADMUX = 0x00;  
	DIDR0 = (1<<ADC0D)|(1<<ADC1D); // Disable the digital circuitry on the ADC inputs.
  
	// Enable the A/D Converter, set the prescaler div8 (125kHz), enable the interrupt.
    ADCSRA=(1<<ADEN)|(1<<ADPS1)|(1<<ADPS0)|(1<<ADIE);


}

void adcOff(void)
{
	ADCSRA &= ~((1<<ADEN)|(1<<ADIE)); 
	// Shut off the ADC and disable the interrupt. 
	// This lowers the power consumption of the uC.
}

// convert adc reading to voltage (readout is multiplied by 10)
uint8_t analog2v1(uint16_t aval)
{
	//double adcval = (double)aval;
	//            ADCout * Vref * Vdiv
	// Voltage = ---------------------- * Calibration Value
	//                     1024
	//
	//return (uint8_t)(((double)aval * 1.2) - 73.6); // These numbers were generated by calibrating against two known voltage reads.
	return (uint8_t)(((double)aval * (double)0.7143) + (double)1.5714);
	//return((uint8_t)r);
}

uint8_t analog2v2(uint16_t aval)
{
	return (uint8_t)(((double)aval * (double)0.7143) + (double)1.5714); // These numbers were generated by calibrating against two known voltage reads.
}


// Start the ADC conversion. Results are handled by an interrupt in main.c.
void startConvert(uint8_t channel) 
{
	// Set channel
	ADMUX &= ~0x1F; // Clear out existing channel value.
	ADMUX |= (channel & 0x1F); // Fill in new channel.
	
    //  start conversion 
	if(bit_is_clear(ADCSRA,ADSC))
		ADCSRA |= (1<<ADSC); 
}


